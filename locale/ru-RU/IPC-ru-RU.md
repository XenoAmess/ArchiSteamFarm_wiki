# IPC

Начиная с версии 3.0 в ASF добавлена система межпроцессного взаимодействия, основанная на http, которая может быть использована для управления процессом. Это альтернатива существующей системе управления через чат Steam.

Команды IPC всегда выполняются с правами `SteamOwnerID`, который по-умолчанию равен `0`. Чтобы ими пользоваться, вам нужно задать `SteamOwnerID` правильное ненулевое значение. Со значением по-умолчанию IPC будет работать, но ни у кого не будет прав отсылать команды (`400 BadRequest`). Больше о параметре `SteamOwnerID` вы можете прочитать в разделе "**[Конфигурация](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU)**".

* * *

## ЧаВО

### Что это вообще такое?

IPC это сокращение от "inter-process communication", межпроцессное взаимодействие, и имеет функционал очень похожий на выполнение **[команд](https://github.com/JustArchi/ArchiSteamFarm/wiki/Commands-ru-RU)** через чат Steam - это позволяет вам управлять процессом ASF во время работы. Однако IPC даёт гораздо больше чем просто отправка команд, поскольку он соединяет все основные возможности ASF в одном месте. Прямо сейчас IPC предлагает вам два "режима" использования - API и дружественный к пользователю графический интерфейс (GUI). API позволяет вам создавать свои утилиты и скрипты, взаимодействующие с ASF, а GUI позволяет вам пользоваться этими API вручную, через удобный интерфейс. Для банальной отправки команд вам будет легче взаимодействовать с ASF через чат Steam с одним из ботов. Однако вы можете пользоваться и IPC, если сочтете что это проще/полезнее для вас.

### Это безопасно?

ASF по умолчанию ожидает соединений только по адресу `127.0.0.1`, а значит доступ к IPC ASF невозможен с любой машины, кроме той где запущен ASF. Поэтому это настолько безопасно, насколько может быть безопасным IPC. Если вы решите изменить установленный по умолчанию адрес привязки `127.0.0.1` на что-то другое, например `*`, то вам следует установить соответствующие правила брандмауэра **самостоятельно**, чтобы разрешить только доверенным IP-адресам доступ к порту ASF. В добавок к этому, сервер должен иметь правильно настроенный ненулевой параметр `SteamOwnerID`, иначе от откажется выполнять любые команды в качестве дополнительной меры безопасности. И в добавок ко всему этому вы можете также установить в параметре `IPCPassword` пароль доступа к IPC, что добавит ещё один уровень дополнительной безопасности.

### Могу ли я использовать протокол HTTPS с шифрованием?

ASF предоставляет только базовый `HttpListener`, который не поддерживает использование протокола HTTPS и установку соответствующих сертификатов, и поддержка такого функционала в ASF только ещё больше усложнит его, и добавит сложностей с управлением сертификатами. Настоятельно рекомендуется использовать для этого **[Обратный прокси](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8)**, такой как **[nginx](https://nginx.org/en)**. Таким образом вы получите полный контроль над сервером http и настроить его как захотите, вместо того чтобы ограничиваться возможностями которые поддерживает `HttpListener` в ASF. Пример конфигурации nginx вы можете найти ниже. Мы включили полный блок `server`, хотя вам в основном будут интересны блоки `location`. Дальнейшую информацию вы можете найти в **[документации nginx](https://nginx.org/ru/docs/)**.

```nginx
server {
        listen *:443 ssl;
        server_name archi.justarchi.net;
        ssl_certificate /path/to/your/certificate.crt;
        ssl_certificate_key /path/to/your/certificate.key;

    location /Api/Log {
        proxy_pass http://127.0.0.1:1242;
#       proxy_set_header Host 127.0.0.1; # Только если надо переопределить настройки по-умолчанию
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host $host:$server_port;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Real-IP $remote_addr;

        # Мы добавляем эти 3 параметра для проксирования websockets см. https://nginx.org/en/docs/http/websocket.html
        proxy_http_version 1.1;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Upgrade $http_upgrade;
    }

    location / {
        proxy_pass http://127.0.0.1:1242;
#       proxy_set_header Host 127.0.0.1; # Только если надо переопределить настройки по-умолчанию
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host $host:$server_port;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

Таким образом вы можете пользоваться полностью безопасным подключением к вашему ASF, как показано ниже.

![Изображение](https://i.imgur.com/ifoEmWs.png)

* * *

## ﻿Сервер

Чтобы запустить IPC вам нужно включить **[параметр глобальной конфигурации](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Файл-глобальной-конфигурации)** `IPC`. Дополнительную информацию вы можете найти в разделе "**[Конфигурация](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU)**". Возможно вы также захтите использовать **[аргумент командной строки](https://github.com/JustArchi/ArchiSteamFarm/wiki/Command-line-arguments-ru-RU)** `--process-required`, хотя это совершенно не обязательно, мы просто решили об этом упомянуть.

Если конфигурация сделана правильно, вы должны заметить что служба IPC активна:

    INFO|ASF|StartServer() Запуск IPC сервера на http://127.0.0.1:1242/...
    INFO|ASF|StartServer() IPC сервер готов!
    

ASF теперь ожидает входящих IPC-соединений по адресу `http://127.0.0.1:1242/` (или по тому адресу, который вы указали в параметре `IPCPrefixes`).

* * *

## Клиент

Для взаимодействия с сервером IPC, предоставляемым ASF, может быть использована любая программа совместимая с http, включая классические веб-браузеры, а также утилиты командной строки, такие как `curl`.

### API

IPC ASF предоставляет полное API для управления ботами, для использования которого необходимо отправлять соответствующие запросы на несколько имеющихся конечных точек. Вы можете использовать эти конечные точки API для создания своих вспомогательных скриптов, утилит, интерфейсов и тому подобного. Отсылка запросов API официально полностью поддерживается командой ASF.

### IPC GUI

В дополнение к запросам API, мы медленно разрабатывает графический интерфейс IPC GUI, который представляет из себя дружественный к пользователю фронтенд для API предоставляемых ASF. Доступ к этому GUI вы можете получить перейдя на главную страницу интерфейся IPC ASF, например `http://127.0.0.1:1242`.

![Изображение](https://user-images.githubusercontent.com/1069029/35774997-e3bceb38-097f-11e8-9e07-bb2d60a04618.png)

IPC GUI на данном этапе находится **на предварительном рассмотрении**, это значт что официально он **не поддерживается** и мы не принимаем сообщения об ошибках (отдельных проблемах) касающихся его. Вы можете делиться своими мыслями, предложениями и сообщениями об ошибках в соответствующих **[issue](https://github.com/JustArchi/ArchiSteamFarm/issues?q=is%3Aissue+is%3Aopen+label%3AIPC)**, посвященных разработке IPC GUI. Ведущий разработчик IPC GUI **[@MrBurrBurr](https://github.com/mrburrburr)**.

* * *

## Коды состояния HTTP

Наше API использует стандартные коды состояния HTTP, и они используются согласно RFC. На данный момент ASF может вернуть следующие коды состояния:

- `200 OK` - запрос завершен успешно.
- `400 BadRequest` - запрос не удался из-за ошибки, проанализируйте тело ответа для получения реальной причины. В большинстве случаев это означает что ASF понял запрос, но отказался его выполнить по той или иной причине (и в теле ответа объясняется, почему).
- `401 Unauthorized` - в ASF установлен `IPCPassword` но вы не смогли успешно пройти **[аутентификацию](#Аутентификация)**.
- `403 Forbidden` - Вы не смогли пройти **[аутентификацию](#Аутентификация)** слишком много раз, доступ к IPC запрещён, попробуйте снова через час.
- `404 NotFound` - URL к которому вы пытаетесь получить доступ, не существует.
- `405 MethodNotAllowed` - Метод HTTP, который вы пытаетесь использовать, недопустим для этой конечной точки API. Эта же ошибка используется если вы пытаетесь получить доступ к конечной точке websocket не инициализировав соединени websocket (upgrade).
- `406 NotAcceptable` - заголовок `Content-Type` вашего запроса недопустим для этой конечной точки API. В основном используется для запросов, в которых от вас требуется передать особое тело запроса, без указания его типа.
- `411 LengthRequired` - ваш запрос `POST` не имеет заголовка `Content-Length`.
- `500 InternalServerError` - сервер IPC попал в критическое состояние, это указывает на проблему в ASF, о которой следует сообщить чтобы её исправили. В нормальной ситуации этот статус нигде не используется. Для ожидаемых ошибок вместо этого используется статус `503`.
- `501 NotImplemented` - этот URL зарезервирован для будущего использования и на данный момент не реализован.
- `503 ServiceUnavailable` - в ASF произошла одна из возможных ошибок в процессе выполнения, и запрос выполнить не удалось. Проверьте журнал ASF чтобы узнать реальную причину.

* * *

## Аутентификация

Интерфейс IPC ASF по умолчанию не нуждается ни в какой аутентификации, поскольку `IPCPassword` установлено значение `null`. Однако, если вы активировали `IPCPassword`, указав ему не пустое значение, любой запрос к интерфейсу IPC ASF требует пароль, совпадающий с установленным в `IPCPassword`. Если вы пропустили аутентификацию или указали неверный пароль, вы получите ошибку `401 - Unauthorized`. Если вы продолжите отправлять запросы без аутентификации, со временем сработает ограничение частоты запросов и вы получите ошибку `403 - Forbidden`.

Аутентификация может быть выполнена двумя общепринятыми способами.

### Заголовок `Authentication`

В основном вам следует использовать заголовки запроса HTTP, установив значение поля `Authentication` равным вашему паролю. Как этого добиться зависит от того, каким инструментом вы пользуетесь для доступа к интерфейсу IPC ASF, например если вы пользуетесь `curl` вам следует добавить в качестве аргумента `-H 'Authentication: MyPassword'`. Таким способом аутентификация передаётся в заголовках запроса, где и должна быть.

### Параметр `password` в строке запроса

В качестве альтернативы вы можете добавить параметр `password` в конец URL, который хотите вызвать, например вызывая `/Api/Command/version?password=MyPassword` вместо `/Api/Command/version`. Этот подход достаточно хорош для большинства случаев, поскольку он дружественный к пользователю, и может быть сохранён в качестве закладки, но очевидно что он в открытом виде показывает ваш пароль, что не всегда допустимо. В добавок это дополнительный параметр в строке запроса, что загромождает вид URL, и создаёт впечатление что он применим только к этому URL, хотя на самом деле он применяется ко всему обмену с IPC.

* * *

Оба способа поддерживаются совершенно одинаково, и это вам решать каким из них пользоваться. Мы всё же рекомендуем использовать заголовки HTTP везде где только можно, поскольку с точки зрения использования это более правильно чем строка запроса - строка запроса в этом случае остаётся только для пользователя, как дружественный к пользователю способ создавать закладки с URL запросов IPC.

* * *

## Cross-Origin Resource Sharing

ASF по умолчанию имеет заголовок `Access-Control-Allow-Origin` равный `*`. Это позволяет, например, скриптам на JavaScript получать доступ к интерфейсу IPC ASF в сторонних GUI и утилитах. Однако, это также означает что кто-то может загрузить потенциально вредоносный скрипт который будет делать запрсы к AFS без вашего ведома и разрешения. Если вы хотеите удостоверится, что такая ситуация не случиться, рекомендуется соответсвенно настроить `IPCPassword`. Таким образом любой скрипт, которых захочет получить доступ к интерфейсу IPC ASF, ему потребуется сначала пройти аутентификацию для каждого запроса, как описано выше.

* * *

## API

В основном наше API является типичным REST API основанном на JSON в качестве основного метода сериализации/десериализации данных. Мы стараемся максимально точно описать ответ, используя как коды ошибок HTTP (когда это применимо), так и ответ JSON который вы можете самостоятельно разобрать чтобы выяснить, окончился ли запрос успешно, и если нет - то почему.

Некоторые конечные точки API могут требовать формирования дополнительных данных, как например соответствующей JSON-структуры в качестве тела запроса, и соответственно установки заголовка `Content-Type` равным `application/json`. Если конечная точка API требует особых входных данных, они будут перечислены вверху описания конечной точки.

Предоставленные ниже примеры запросов/ответов показывают возможное использование с помощью утилиты **[curl](https://curl.haxx.se)** - ожидается что вы измените параметр URL добавив в начало соответствующие `Protocol://Host:Port`, согласно настройкам вашего ASF, например `http://127.0.0.1:1242`.

Цифровые параметры определены с максимальными значениями, поэтому вы можете использовать для них строгую типизацию, как например `uint` для `AppID`, и `ulong` для `SteamID`. Некоторые поля типа `ulong`, сериализованные как числа, могут иметь дополнительные поля с префиксом `s_`, сериализованные как строки, что может быть использовано в JavaScript, который не способен точно представлять 64-разрядные числа (также верно для других языков с подобным ограничением).

* * *

### GenericResponse

Стандартный формат ответа (GenericResponse) это основной возвращаемый тип для всех вызовов API.

```json
{
    "Message": "string",
    "Result": {},
    "Success": true
}
```

`Message` - значение типа `string`, содержащее дополнительные подробности ответа. Это может быть просто "OK" если запрос успешен, или реальная причина отказа если нет. Мы используем это поле как способ дать вам знать что случилось с отправленным вами запросом. Помните, что это поле НЕ результат вашего запроса, а только описание того, что произошло. Может быть равным null если у нас нет определённого сообщения для вас, хотя мы стараемся по возможности избегать таких ситуаций.

`Result` - значение типа `object` содержащее результат вашего запроса. Тип этого поля зависит от вызванной конечной точки API- например это может быть `Bot` или `string`. Чаще всего используется в запросах `GET` для получения данных которые вы запросили. Хотя это поле имеет гибкий тип, конкретные конечные точки всегда гарантируют определённое количество возможных результатов, и очень часто можно использовать строгую типизацию для отдельно взятой конечной точки. Может быть равным null если у нас нет определённого результата для вас.

`Success` - значение типа `bool`, предоставляющее простой способ проверки результата. Это дополнение к кодам состояния HTTP, поскольку коды `2xx` считаются `true`, а всё остальное считается `false`. Обратите внимание, что это поле только указывается что **запрос API успешен** - вам необходимо разобрать поле `Result` чтобы проверить, успешно ли заданное действие, такое как отправка команды.

* * *

### `GET /Api/ASF`

Эта конечная точка API может быть использована для получения общих сведений о процессе ASF в целом. Возвращает **[GenericResponse](#genericresponse)** c полем `Result` определённым как **[ASFResponse](#asfresponse)**.

```shell
curl -X GET /Api/ASF
{"Message":"OK","Result":{"BuildVariant":"generic","GlobalConfig":{"AutoRestart":false,"Blacklist":[440]},"MemoryUsage":1843,"ProcessStartTime":"2018-01-30T21:32:01.8132984+01:00","Version":{"Major":3,"Minor":0,"Build":6,"Revision":1,"MajorRevision":0,"MinorRevision":1}},"Success":true}
```

#### ASFResponse

```json
{
    "BuildVariant": "string",
    "GlobalConfig": {
        "AutoRestart": false,
        "Blacklist": [ 440 ]
    },
    "MemoryUsage": 4294967295,
    "ProcessStartTime": "9999-12-31T23:59:59.9999999+12:00",
    "Version": {
        "Major": 2147483647,
        "Minor": 2147483647,
        "Build": 2147483647,
        "Revision": 2147483647,
        "MajorRevision": 32767,
        "MinorRevision": 32767
    }
}
```

`BuildVariant` - значение типа `string`, содержащее вариант сборки запущенного процесса ASF. Это может быть любой вариант доступный в разделе "**[releases](https://github.com/JustArchi/ArchiSteamFarm/releases)**", а также варианты не доступные для скачивания официально (такие как вариант `docker` для нашего образа Docker или вариант `source` для неофициальных сборок).

`GlobalConfig` - специальный объект C# используемый для доступа к конфигурации. Имеет точно такую же структуру как **[файл глобальной конфигурации](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Файл-глобальной-конфигурации)**, описанный в разделе "Конфигурация". Это свойство может быть использовано чтобы узнать с какими параметрами настроен работать процесс ASF. Обычно этот объект будет включать только часть параметров конфигурации - те, которые пользователь изменил (минимальная конфигурация). Конфиденциальная информация, указанная в конфигурации процесса (например, `WebProxyPassword`), всегда исключается из выдачи.

`MemoryUsage` - значение типа `uint`, содержащее объём памяти **управляемого** кода, занятый процессом ASF в целом, в килобайтах.

`ProcessStartTime` - значение типа `DateTime`, содержащее точное время запуска процесса ASF. Может использоваться, например, для вычисления общего времени работы программы. Для JSON ASF сериализует объект `DateTime` в строку стандарта **[ISO 8601](https://ru.wikipedia.org/wiki/ISO_8601)** содержащую дату, время и используемый часовой пояс.

`Version` - значение типа `Version`, содержащее версию запущенного двоичного файла ASF. Тип `Version` содержит 4 важных свойства `Major`, `Minor`, `Build` и `Revision`, которые соответствуют цифрам в записи `A.B.C.D` версии ASF.

* * *

### `POST /Api/ASF`

#### Тело:

Content-Type: application/json

```json
{
    "GlobalConfig": {},
    "KeepSensitiveDetails": true
}
```

Эта конечная точка API может использоваться для обновления **[файла глобальной конфигурации](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Файл-глобальной-конфигурации)** ASF. Другими словами, это обновит файл `ASF.json` в папке `config` содержимым **[GlobalConfig](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Файл-глобальной-конфигурации)** объекта JSON переданного в теле запроса. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` заданным как `null`.

`GlobalConfig` - JSON-объект со структурой аналогичной **[файлу глобальной конфигурации](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Файл-глобальной-конфигурации)**. Это поле является обязательным и не может быть равным `null`. Параметры конфигурации со значением, равным значению по-умолчанию, могут быть опущены, как и в обычной конфигурации ASF.

`KeepSensitiveDetails` - это значение типа `bool`, указывающее должна ли конфиденциальная информация, такая как `WebProxyPassword`, быть скопирована из существующей конфигурации (если есть). Это поле необязательное, и по умолчанию считается равным `true`. Когда это поле включено, параметры с конфиденциальной информацией, указанные со значением `null`, будут скопированы из текущей конфигурации.

На данный момент следующие параметры считаются конфиденциальной информацией и могут быть заданы равными `null` для копирования из существующей конфигурации: `WebProxyPassword`.

```shell
curl -X POST -H "Content-Type: application/json" -d '{"GlobalConfig":{"AutoRestart":false,"BackgroundGCPeriod":0}}' /Api/ASF
{"Message":"OK","Result":null,"Success":true}
```

* * *

### `DELETE /Api/Bot/{BotNames}`

Эта конечная точка API может использоваться для полного удаления заданных ботов с указанными именами `BotNames`, вместе со всеми файлами. Иными словами, это удалит файлы `BotName.*` (включая, но не ограничиваясь `json`, `db`, `bin`, `maFile`, `keys` и т.д.) из вашей папки `config` для всех заданных ботов. Эта конечная точка принимает несколько имен ботов в `BotNames`, разделённых запятыми, а также ключевое слово `ASF` для удаления всех имеющихся ботов. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` заданным как `null`.

```shell
curl -X DELETE /Api/Bot/archi
{"Message":"OK","Result":null,"Success":true}
```

* * *

### `GET /Api/Bot/{BotNames}`

Эта конечная точка API может быть использована для получения сведений о состоянии ботов с указанными `BotNames` - она возвращает базовые сведения о состоянии ботов. Эта конечная точка принимает несколько имен ботов в `BotNames`, разделённых запятыми, а также кодовое слово `ASF` для выбора всех существующих ботов. Returns **[GenericResponse](#genericresponse)** с полем `Result` определённым как `ImmutableHashSet<Bot>` - массив сообщений о состоянии ботов.

```shell
curl -X GET /Api/Bot/archi
{"Message":"OK","Result":[{"BotName":"archi","CardsFarmer":{"CurrentGamesFarming":[],"GamesToFarm":[],"TimeRemaining":"00:00:00","Paused":false},"AccountFlags":0,"AvatarHash":"99bf6df8ad1836c0205de22935f6fe4b1f96b0c6","IsPlayingPossible":true,"SteamID":0,"BotConfig":null,"KeepRunning":false}],"Success":true}
```

#### Bot

```json
{
    "BotName": "string",
    "CardsFarmer": {
        "GamesToFarm": [{
            "AppID": 4294967295,
            "GameName": "string",
            "HoursPlayed": 3.40282347E+38,
            "CardsRemaining": 65535
        }],
        "CurrentGamesFarming": [{
            "AppID": 4294967295,
            "GameName": "string",
            "HoursPlayed": 3.40282347E+38,
            "CardsRemaining": 65535
        }],
        "TimeRemaining": "02:30:00",
        "Paused": false
    },
    "AccountFlags": 4294967295,
    "AvatarHash": "string",
    "IsPlayingPossible": true,
    "SteamID": 18446744073709551615,
    "BotConfig": {
        "Enabled": true,
        "Paused": true
    },
    "KeepRunning": true
}
```

`BotName` это параметр типа `string`, содержащий имя бота. Это тот же самый идентификатор, который используется для команд и других действий с ботами.

`CardsFarmer` это специализированный объект C#, используемый ботом для фарма карточек. Он содержит информацию, связанную с процессом фарма карточек для данного бота. Его структура описана **[ниже](#cardsfarmer)**.

`AccountFlags` это параметр типа `EAccountFlags` (флаги `uint`), определённый в SK2 (**[тут](https://github.com/SteamRE/SteamKit/blob/master/Resources/SteamLanguage/enums.steamd#L81-L116)**), который содержит флаги аккаунта Steam для данного аккаунта. Этот параметр может использоваться для получения дополнительной информации о состоянии аккаунта Steam, используемого в ASF, например чтобы узнать что он **[ограниченный](https://support.steampowered.com/kb_article.php?ref=3330-IAGK-7663)** путём проверки флагов `LimitedUser` или `LimitedUserForce`. Этот параметр инициализируется (и обновляется) в тот момент когда бот входит в сеть Steam, поэтому он будет иметь значение `0` до первого входа.

`AvatarHash` это параметр типа `string`, содержащий хеш аватара Steam используемого данным ботом. Есть возможность использовать это значение для формирования URL, ведущего к аватару пользователя, сохранённому в CDN Steam. Может иметь значение `null` если пользователь не установил аватар.

`IsPlayingPossible` это параметр типа `bool`, указывающий на то, что аккаунт, используемый в боте, может быть использован для автоматического фарма. Этот параметр будет иметь значение `false`, если библиотека Steam этого аккаунта уже где-то используется, либо напрямую, либо через Family Sharing. Этот параметр учитывает только удалённые сеансы, и не включает в себя собственный процесс (поэтому если аккаунт не используется где-то ещё, `IsPlayingPossible` всегда будет равен `true`, даже если ASF активно фармит игры на нём прямо сейчас).

`SteamID` это параметр типа `ulong`, содержащий уникальный идентификатор steamID используемого аккаунта в 64-битном формате. Этот параметр будет иметь значение `0`, если бот не вошёл в сеть Steam (и поэтому может использоваться для определения того, произведен вход на аккаунте или нет).

`BotConfig` это специализированный объект C#, используемый ботом для доступа к его конфигурации. Имеет точно такую же структуру как **[конфигурация бота](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Конфигурация-бота)**, описанная в разделе "Конфигурация". Этот параметр может использоваться для того, чтобы определить настройки, с которыми бот сконфигурирован работать. Обычно этот объект будет включать только часть параметров конфигурации - те, которые пользователь изменил (минимальная конфигурация). Конфиденциальная информация об аккаунте, такая как `SteamLogin`, `SteamPassword` и `SteamParentalPIN` всегда исключается из выдачи.

`KeepRunning` это параметр типа `bool`, указывающий на то что заданный бот в данный момент активен. Активный бот - это бот, который был запущен, либо самим ASF при старте, либо пользователем в процессе работы. Если бот остановлен, этот параметр будет иметь значение `false`. Помните, что этот параметр не имеет ничего общего со входом в сеть Steam (для определения входа может использоваться параметр `SteamID`).

#### CardsFarmer

`GamesToFarm` это объект типа `ImmutableHashSet<Game>` (массив элементов типа `Game`) содержащий игры, которые запланировано фармить в текущей сессии. Пожалуйста, обратите внимание, что этот массив обновляется по мере необходимости, с учётом производительности. Например, если вы фармите используя алгоритм фарма `Simple`, ASF не будет проверять есть ли у нас новые игры для фарма при добавлении игры на аккаунт (поскольку мы всё равно проверим это по окончании текущей очереди, а не делая этого немедленно мы уменьшим количество запросов и загрузку канала). Поэтому эти данные верны только для текущей сессии фарма, которая может отличаться от глобальных данных.

`CurrentGamesFarming` это объект типа `ImmutableHashSet<Game>` (массив элементов типа `Game`) который содержит игры, которые фармятся прямо сейчас. По сравнению с `GamesToFarm`, этот параметр определяет текущее состояние, а не очередь ожидания, и существенно зависит от выбранного алгоритма фарма карточек. Этот массив может содержать не более `32` игр (задаётся параметром `MaxGamesPlayedConcurrently` со стороны сети Steam). Также, вы можете быть уверены, что в этом массиве могут быть только элементы, уже присутствующие в `GamesToFarm`.

`TimeRemaining` это параметр типа `TimeSpan`, содержащий приблизительное расчетное время, требуемое на окончание фарма игр, заданных в `GamesToFarm`. Этот параметр даже приблизительно не соответствует времени, которое реально потребуется, но это неплохой индикатор, точность которого может быть улучшена в дальнейшем, и подходит для различных задач отображения состояния. Этот параметр не обновляется в режиме реального времени, он вычисляется исходя из текущего значения `GamesToFarm`, и соответственно пересчитывается в момент изменения `CardsRemaining` в любой игре.

`Paused` это параметр типа `bool`, содержащий признак того, что модуль `CardsFarmer` находится в режиме паузы. CardsFarmer может быть в режиме паузы из-за различных событий, в основном из-за получения команд `pause` и `play`. Находясь в режиме паузы, CardsFarmer не будет пытаться фармить в автоматическом режиме, и не будет проверять страницы значков каждые `IdleFarmingPeriod` часов.

#### Game

`AppID` это параметр типа `uint`, содержащий уникальный идентификатор запущенной игры. ASF следит чтобы этот параметр всегда был больше `0`.

`GameName` это параметр типа `string`, содержащий название игры с идентификатором `AppID`. Эти данные возвращает Steam Community. ASF следит чтобы это значение соответствовало критериям `non-null` и `non-empty`.

`HoursPlayed` это параметр типа `float`, содержащий информацию о том, сколько часов была запущена игра. Этот параметр обновляется в режиме реального времени, но по необходимости, не реже чем каждые `FarmingDelay` минут. Обратите, пожалуйста, внимание, что исходно эти данные получаются от Steam Community, но затем обновляются согласно встроенным таймерам ASF, и поэтому могут не соответствовать тому, что вовзращает Steam Community, поскольку Steam Community также не обновляется в режиме реального времени, а ASF требуются эти данные чтобы остановить фарм для накрутки времени как только этот параметр достигает значения `HoursUntilCardDrops`. ASF следит чтобы этот параметр был не менее `0.0`.

`CardsRemaining` это параметр типа `ushort`, содержащий количество карточек, доступных для получения из этой игры. Этот параметр обновляется как можно быстрее, и всегда должен иметь значение больше `0`. Однако, возможна ситуация когда этот параметр будет иметь значение `0` в коротком интервале когда ASF переключается на следующую игру.

* * *

### `POST /Api/Bot/{BotName}`

#### Тело:

Content-Type: application/json

```json
{
    "BotConfig": {},
    "KeepSensitiveDetails": true
}
```

Эта конечная точка API может использована для создания/обновления **[конфигурации бота](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Конфигурация-бота)** с именем `BotName`. Другими словами, такой запрос обновит файл `BotName.json` в папке `config` содержимым JSON объекта **[BotConfig](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Конфигурация-бота)** переданном в теле запроса. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` заданным как `null`.

`BotConfig` это объект JSON типа **[BotConfig](https://github.com/JustArchi/ArchiSteamFarm/wiki/Configuration-ru-RU#Конфигурация-бота)**. Это поле является обязательным и не может быть равным `null`. Параметры конфигурации со значением, равным значению по-умолчанию, могут быть опущены, как и в обычной конфигурации ASF.

`KeepSensitiveDetails` это параметр типа `bool`, задающий, должна ли конфиденциальная информация, такая как `SteamLogin` или `SteamPassword` наследоваться из существующей конфигурации (если есть). Это поле необязательное, и по умолчанию считается равным `true`. Когда это поле включено, параметры с конфиденциальной информацией, указанные со значением `null`, будут скопированы из текущей конфигурации.

На данный момент следующие параметры считаются конфиденциальной информацией и могут быть заданы равными `null` для копирования из существующей конфигурации: `SteamLogin`, `SteamPassword`, `SteamParentalPIN`.

```shell
curl -X POST -H "Content-Type: application/json" -d '{"BotConfig":{"Enabled":false,"Paused":true}}' /Api/Bot/archi
{"Message":"OK","Result":null,"Success":true}
```

* * *

### `POST /Api/Command/{Command}`

#### Тело: пустое

Эта конечная точка API может использоваться для выполнения команды, заданной `{Command}`. Рекомендуется всегда указывать имя бота, который должен выполнить команду, иначе вместо этого будет использован первый заданный бот. Возвращает **[GenericResponse](#genericresponse)** c полем `Result` определённым как `string` и содержащим результат исполнения команды.

```shell
curl -X POST -d '' /Api/Command/version
{"Message":"OK","Result":"\r\n<archi> ASF V3.0.5.3","Success":true}
```

* * *

### `DELETE /Api/GamesToRedeemInBackground/{BotName}`

Эта конечная точка API может использоваться для полноо удаления файлов `.keys.used` и `.keys.unused` из папки `config` для бота заданного `BotNames`. Эта конечная точка принимает несколько имен ботов в `BotNames`, разделённых запятыми, а также ключевое слово `ASF` для удаления указанных файлов у всех имеющихся ботов. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` заданным как `null`.

```shell
curl -X DELETE /Api/GamesToRedeemInBackground/archi
{"Message":"OK","Result":null,"Success":true}
```

* * *

### `GET /Api/GamesToRedeemInBackground/{BotName}`

Эта конечная точка API может использоваться для получения файлов `.keys.used` и `.keys.unused` из папки `config` для бота заданного `BotNames`. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` определенным как `ImmutableDictionary<string, GamesToRedeemInBackgroundResponse>` - ассоциативный массив, задающий соответствие `BotName` к **[GamesToRedeemInBackgroundResponse](#gamestoredeeminbackgroundresponse)** (описан ниже).

```shell
curl -X GET /Api/GamesToRedeemInBackground/archi
{"Message":"OK","Result":{"archi":{"UnusedKeys":{"AAAAA-BBBBB-CCCCC":"Orwell","XXXXX-YYYYY-ZZZZZ":"Factorio"},"UsedKeys":{}}},"Success":true}
```

#### GamesToRedeemInBackgroundResponse

```json
{
    "UnusedKeys": {
        "string": "string",
        "string": "string"
    },
    "UsedKeys": {
        "string": "string",
        "string": "string"
    }
}
```

`UnusedKeys` и `UsedKeys` это объекты типа `ImmutableDictionary<string, string>`, задающие соответствие ключей Steam (`key`) с их названиями (`value`). Это результат запроса `POST`, описанного ниже, и может использоваться для удаленного получения ключей без доступа к папке `config` ASF. Оба эти объекта могут иметь значение `null` в случае ошибки ASF при доступе к файлам (например, ошибки ввода-вывода), но пустые или отсутствующие файлы будут обработаны штатно и будет возвращен пустой массив.

* * *

### `POST /Api/GamesToRedeemInBackground/{BotName}`

#### Тело:

Content-Type: application/json

```json
{
    "GamesToRedeemInBackground": {
        "string": "string",
        "string": "string"
    }
}
```

Эта конечная точка может использоваться для добавления дополнительных **[игр для активации в фоновом режиме](https://github.com/JustArchi/ArchiSteamFarm/wiki/Background-games-redeemer-ru-RU)** боту с заданным `BotName`. Возвращает **[GenericResponse](#genericresponse)** with `Result` определённый как `OrderedDictionary<string, string>`.

`GamesToRedeemInBackground` это объект JSON типа `OrderedDictionary<string, string>` задающий соответствие между ключами для активации (`key`) и их названиями (`value`). Это поле является обязательным и не может быть равным `null`. Ни одно поле `key` или `value` в массиве не может быть пустым или равным `null`. В дополнение к этому, каждый `key` должен иметь правильную для ключа Steam структуру, ASF будет проверять это с помощью регулярного выражения. Неверные элементы будут автоматически удалены в процессе импорта.

`Result` это `GamesToRedeemInBackground` содержащий игры которые были успешно добавлены в очередь на активацию. Как указано выше, неверные элементы автоматически удаляются в процессе импорта, поэтому этот результат можно сравнить с исходным запросом для проверки, какие элементы были признаны неверными и пропущены в процессе импорта. Если в запросе не было неверных данных, этот результат должен быть в точности таким же, как `GamesToRedeemInBackground` который вы отправили ASF.

```shell
curl -X POST -H "Content-Type: application/json" -d '{"GamesToRedeemInBackground":{"AAAAA-BBBBB-CCCCC":"Orwell","XXXXX-YYYYY-ZZZZZ":"Factorio"}}' /Api/GamesToRedeemInBackground/archi
{"Message":"OK","Result":{"AAAAA-BBBBB-CCCCC":"Orwell","XXXXX-YYYYY-ZZZZZ":"Factorio"},"Success":true}
```

* * *

### `GET /Api/Log`

Эта конечная точка API может использоваться для получения сообщений журнала ASF в реальном времени. По сравнению с другими конечными точками, эта использует соединение по протоколу **[websocket](https://ru.wikipedia.org/wiki/WebSocket)** для выдачи обновлений в реальном времени. Каждое сообщение кодируется в формате **[UTF-8](https://ru.wikipedia.org/wiki/UTF-8)** и содержит структуру **[GenericResponse](#genericresponse)** с полем `Result` определённым как `string` - в нём содержится сообщение, сформированное согласно заданной пользователем конфигурации NLog. В начале подключения, ASF также выдаст пакет из нескольких последних сообщений журнала в качестве краткой истории (по умолчанию последние 20, но пользователь может изменить это число, а также отключить выдачу истории полностью).

Подключение по протоколу websocket, установленное с помощью этой конечной точки, работает в режиме **только для чтения** - ASF будет принимать только **[управляющие пакеты](https://tools.ietf.org/html/rfc6455#section-5.5)**, в особенности пакет `Close` индицирующий что соединение должно быть штатно завершено. Попытка отправить любой пакет с данными приведёт к разрыву соединения.

```shell
curl -X GET -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" /Api/Log
HTTP/1.1 200 OK

# Example of messages being sent by ASF, keep in mind that result string is affected by user-specified NLog logging layout
{"Message":"OK","Result":"2018-01-31 03:19:34|dotnet-2884|INFO|ASF|Start() IPC server ready!","Success":true}
```

* * *

### `GET /Api/Structure/{Structure}`

Эта конечная точка API может использоваться для получения структуры заданных объектов JSON, указанных с помощью имени `Structure` - она возвращает объект по умолчанию с данной структурой, сериализованый в формат JSON. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` определённым как `object`.

`{Structure}` может быть любой структурой ASF или .NET Core, заданной с помощью пространства имен и имени, например `ArchiSteamFarm.BotConfig`, `ArchiSteamFarm.GlobalConfig` или `ArchiSteamFarm.Json.Steam+Asset.`

В примере ниже реальный результат был обрезан для ясности - в нормальных условиях будет возвращена структура целиком, в этом главная задача этой конечной точки. Результирующая структура всегда включает все поля и свойства типа public и non-public (но не включает private).

```shell
curl -X GET /Api/Structure/ArchiSteamFarm.BotConfig
{"Message":"OK","Result":{"AcceptGifts":false,"TradingPreferences":0},"Success":true}
```

По сравнению с `GET /Api/Type`, эта конечная точка возвращает представленный в формате JSON объект заданного типа, в состоянии по умолчанию.

* * *

### `GET /Api/Type/{Type}`

Эта конечная точка API может использоваться для получения информации о заданном типе по его имени. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` определенным как **[TypeResponse](#typeresponse)**.

`{Type}` может быть любым типом ASF или .NET Core, заданным с помощью пространства имен и имени, например`ArchiSteamFarm.BotConfig`, `ArchiSteamFarm.GlobalConfig` или `ArchiSteamFarm.Json.Steam+Asset.`

В примере ниже реальный результат был обрезан для ясности - в нормальных условиях будет возвращена структура целиком, в этом главная задача этой конечной точки. Результирующая структура всегда включает все поля и свойства типа public и non-public.

```shell
curl -X GET /Api/Type/ArchiSteamFarm.BotConfig
{"Message":"OK","Result":{"Body":{"AcceptGifts":"System.Boolean","TradingPreferences":"ArchiSteamFarm.BotConfig+ETradingPreferences"},"Properties":{"BaseType":"System.Object","CustomAttributes":null,"UnderlyingType":null}},"Success":true}
```

По сравнению с `GET /Api/Structure`, эта конечная точка возвращает обхект заданного типа, где все значения закодированы как строковый тип заданного свойства. Вы также можете использовать эту конечную точку рекурсивно, например чтобы проверить как именно задаётся `ArchiSteamFarm.BotConfig+ETradingPreferences` в примере выше.

#### TypeResponse

```json
{
    "Body": {},
    "Properties": {
        "BaseType": "string",
        "CustomAttributes": [ "string" ],
        "UnderlyingType": "string"
    }
}
```

`Body` - это параметр типа `ImmutableDictionary<string, string>`, содержащее информацию о том, какие свойства возможно установить для данного типа. Это включает в себя все поля и свойства типов public и non-public (но не private) в объекте заданного типа. `Key` в этом ассоциативном массиве это имя поля/свойства, а `Value`, ассоциированное с данным ключом, это соответствующий ему тип C#. Этот параметр может быть пустым если заданный тип не включает в себя никаких полей или свойств. Мы также используем этот параметр для дальнейшего разбора заданного типа, например `BaseType` для типа `System.Enum` будет иметь верные значения перечисления указанные здесь, где `Key` будет именем отдельного значения перечисления, а `Value` будет реальным значением для этого имени.

`Properties` - параметр типа `TypeProperties`, описанного **[ниже](#typeproperties)**, содержащий информацию о метаданных заданного типа.

#### TypeProperties

`BaseType` - это значение типа `string` содержащее базовый тип для заданного типа. Например, это будет `System.Object` для объекта `ArchiSteamFarm.BotConfig`, и `System.Enum` для `ArchiSteamFarm.BotConfig+ETradingPreferences`. Основываясь на этом значении вы можете частично использовать строгую типизацию для содержимого `Body`, заранее зная как его следует разбирать (например для `System.Enum`, `Body` будет содержать имена перечисления и их значения, как сказано выше в описании параметра `Body`).

`CustomAttributes` - это значение типа `ImmutableHashSet<string>` указывающее, какие пользовательские атрибуты применимы к этому типу. Этот параметр особенно полезен, когда `BaseType` это `System.Enum`, поскольку в этом случае вы можете проверить, является ли этот тип специальным перечислением типа `flags`, проверив задан ли в этом параметре элемент `System.FlagsAttribute`. Этот параметр может иметь значение `null` когда для заданного объекта не определены пользовательские атрибуты. Вместе с параметром `UnderlyingType`, это может сказать вам, что `ArchiSteamFarm.BotConfig+ETradingPreferences` это перечисление `byte flags`.

`UnderlyingType` - это значение типа `string`, содержащее название внутрилежащего типа для заданного типа. Используется в основном с `System.Enum` чтобы узнать, какой внутрилежащий тип использует это перечисление для хранения данных. Например для большинства перечислений в ASF это будет `System.Byte`. Вместе с параметром `CustomAttributes`, это может сказать вам, что `ArchiSteamFarm.BotConfig+ETradingPreferences` это перечисление `byte flags`.

* * *

## WWW API

APIs below are dedicated for our IPC GUI usage and they should not be used by remote scripts or tools. Эта документация служит для внутреннего использования и может изменяться в любое время и любым образом. Вам не следует полагаться на существование конечных точек, описанных ниже, и не следует использовать их в ваших собственных утилитах.

* * *

### `GET /Api/WWW/Directory/{Directory}`

Эта конечная точка API может использоваться для получения содержимого папки указанной с помощью относительного пути, по отношению к папке `www`. Возвращает **[GenericResponse](#genericresponse)** c полем `Result` определенным как `ImmutableHashSet<string>` - массив с именами файлов.

```shell
curl -X GET /Api/WWW/Directory/css
{"Message":"OK","Result":["app.css","_all-skins.min.css","_nightmode.min.css"],"Success":true}
```

* * *

### `POST /Api/WWW/Send`

#### Тело:

Content-Type: application/json

```json
{
    "URL": "string"
}
```

Эта конечная точка API для внутреннего использования, позволяет отправлять удалённые запросы `GET`. Должна использоваться только если **[CORS](https://ru.wikipedia.org/wiki/Cross-origin_resource_sharing)** не позволяет отправить запрос обычным образом. Возвращает **[GenericResponse](#genericresponse)** с полем `Result` определённым как `string` и содержащим внутренний html, возвращенный запросом `GET`.

`URL` это параметр типа `string`, задающий URL по которому необходимо выполнить запрос `GET`. Должен начинаться с `https://`.

```shell
curl -X POST -H "Content-Type: application/json" -d '{"URL":"https://example.com"}' /Api/WWW/Send
{"Message":"OK","Result":"<!doctype html>\n<html>\n<head>\n    <title>Example Domain</title>...","Success":true}
```